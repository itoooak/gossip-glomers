# 実装ログ

## 実装
課題が書かれたページは[Challenge #2: Unique ID Generation · Fly Docs](https://fly.io/dist-sys/2/)

やることは、ネットワークの分断が起こりうる状況でもグローバルに一意性を保つIDの割り当て

解説がないので、調べながら自力で進めていく必要がある

まずは前章のソースをほとんどそのまま使うIDを全て`1`にして、テストが落ちることを確認する

```
Analysis invalid! (ﾉಥ益ಥ）ﾉ ┻━┻
```
もちろん落ちる
(全く関係ない話だが、日本語が入っていると顔文字が上手く認識できない)


### 調査
ひとまず動くものを実装するという目的でやっていく

そのため、Goではどのライブラリが使えるのかということを主に調べていく

- [ユースケースに応じたユニークなIDの生成 - Carpe Diem](https://christina04.hatenablog.com/entry/golang-uuid)
    - 衝突は完全回避というよりは確率的に回避するという方向性らしい
- [ID生成についてのメモ](https://zenn.dev/miyataka/scraps/0f56c79d0dbdb5)

今回は[xid](https://github.com/rs/xid)を使うことにする


### コードを書く
xidを使うだけ

実際にプログラムを書く上ではこれくらいで十分なのかもしれないが、ブラックボックスすぎるというか、簡単すぎるというか

中身が完全に理解できているというわけではないが、どうライブラリを使うといいのか、どうコードを書けばいいのかについてはある程度理解が得られたと思う


## テスト
```sh
../maelstrom/maelstrom test -w unique-ids --bin ~/go/bin/maelstrom-unique-ids --time-limit 30 --rate 1000 --node-count 3 --availability total --nemesis partition
```

```
Everything looks good! ヽ(‘ー`)ノ
```
OK!

## やり残していること
実際にやれる/やるかどうかは不明だが、挙げてみる

- ユニークIDの生成を自分で書く
    - ノードが3つしか作られず、同時に大量のIDを生成するという必要がないため、衝突回避はそこまで大変ではなさそう
        - 時間をIDに含め、少し追加の情報を含めれば達成可能に思える
- 衝突する確率の評価
    - 実際にはどれくらいの確率で衝突が起こってしまうのか
        - 秒あたりの生成数が増加した場合
        - IDが長い時間有効である必要がある場合
- 実行速度の評価/比較
    - IDの生成手法ごとに、どれくらいの速度で動作するのかを比較する
- テストの負荷を上げる
    - より厳しい状況において、どこで壊れるのか(それとも壊れないのか)を調べる
